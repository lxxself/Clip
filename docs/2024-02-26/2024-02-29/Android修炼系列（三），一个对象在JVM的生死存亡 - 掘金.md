---
id: 6e58bcc3-998a-4b8f-afe8-fb07db70de6c
---

# Android修炼系列（三），一个对象在JVM的生死存亡 - 掘金
#Omnivore

[Read on Omnivore](https://omnivore.app/me/android-jvm-18df416cd7e)
[Read Original](https://juejin.cn/post/6935481800365981727)

当我们new了一个对象，会发生什么呢？来段代码：

```angelscript
public class Tested {
    public static int T = 10;
    public int c = 1;
}

```

### 类初始化

在编译期，编译器会将 Tested.java类转换成 Tested.class 字节码文件。当虚拟机接收到new 字节码指令时，如果此时类还未被初始化，则虚拟机会先进行类的初始化过程。

![](https://proxy-prod.omnivore-image-cache.app/0x0,srQ5haV_7i1io9scBvdLi1Y-yLMp1LajL-8aQe2Bsrkg/https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/061695bda28a4c538e480b78ba61e0bf~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

在类加载完成后。虚拟机会为new Tested() 的Tested对象，在java堆中分配内存。而对象所需要的内存大小在类加载完成后就被确定了。

### 指针碰撞

如果 java 中的内存是规整的，即使用过的放在一边，空闲的在另一边，中间放着指针作为分界点的指示器。那所分配的内存就仅仅是将指针像空闲空间挪动一段与对象大小相等的距离。这种方式内称为指针碰撞。

### 空闲列表

如果 java 中的内存是不工整的，使用过的和空闲的内存相互交错，那么虚拟机就必须维护一个列表记录哪些内存是可用的。在分配的时候从列表中找到一块足够大的空间给对象示例，并更新表的记录。这种分配方式称为空闲列表。

### 对象初始化

当我们的对象内存被分配完毕后，虚拟机就会对对象进行初始化操作。

![](https://proxy-prod.omnivore-image-cache.app/0x0,sltb0EIeje6Ok2weWlWRL7am94VdmmXV36Tf8MDNZR_U/https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/675ae4ce8a5e4a4cb8f89e86c650e58d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

此时Tested 对象在我们眼里就算出生了，在虚拟机眼里就是真正可用的了。可对象的生命并不是无穷的，它也会经历自己的死亡。

### 可达性分析

在主流实现中，我们通过可达性分析来判断一个对象是否存活。实现思路是：通过一系列被称为 “GC Roots” 的对象作为起始点，从这些节点开始像下搜索，搜索所走的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。见图：

![在这里插入图片描述](https://proxy-prod.omnivore-image-cache.app/0x0,sZA3Q1ABnQY4aA_6Fa12UtiqSlD97xuBIbuFEAOmnpnc/https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c94e46e9ff4d448368d56a634c7a81~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

即使 Obj5 与 Obj4 由于与 GC Roots 没有引用链相连，所以我们称 GC Roots 到对象 Obj4 和 Obj5 不可达。所以 Obj4 和 Obj5 就是可回收的。

既然Obj4 和 Obj5 是可回收的，那么是否一定会被回收呢？不一定。此时虚拟机会进行第一次的标记过程。因为 java 内能够重写 finalize() 方法（在这里只是分析特例，不推荐在任何情况下使用此方法），当对象重写了此方法，并且 finalize() 方法还未被虚拟机调用，那么虚拟机就会将此对象放入一个专门的F-Queue队列，由一个单独的 Finalizer 线程去执行它，如果队列中对象的 finalize() 方法在虚拟机第二次标记之前执行，并在此次执行过程中又将自己与GC Roots 引用链相连，那么虚拟机在进行第二次标记时，就会将该对象从 F-Queue队列移除，否则就宣告该对象死亡。==注意：finalize() 方法只会被执行一次，所以一个对象一生只有一次机会进入F-Queue队列，有机会逃脱本此死亡。==

如果对象已经宣告死亡了，那么虚拟机怎么来回收它吗？

### ==标记-清除算法==

==这是最基础的收集算法，主要分为标记和清除两个阶段。首先标记出所以需要回收的对象，在标记完成后统一回收所有被标记的对象。==可以参考上面的空闲列表。其有两点不足：

a. 效率问题，标记和清除两个过程效率都不高。

b. 空间问题，因为堆中的内存不是规整的，已使用的和空闲的内存相互交错，这也就导致了每次GC回收后，产生大量的内存碎片，而当再次分配一个大对象时，如果无法找到足够的连续内存，又会再此触发GC回收。

### 复制算法

==复制算法是将堆内存分成大小相等的两块，每次只使用其中一块，这样内存就是规整的了，参考指针碰撞。每当一块内存使用完了，就将该块内存中存活的对象复制到另一边，随后将该块内存一次清理掉。==

现在的虚拟机都采用这种方式来回收新生代，只是并不是按照1:1的比例来划分内存，而是将内存分为一块较大的 Eden 空间，和两块较小的 Survivor 空间（HotSpot虚拟机默认Eden：Survivor = 8 :1）。每次只使用 Eden 和 其中一块 Survivor 空间，当回收时，将 Eden 空间和当前正使用的 Survivor 空间内存活的对象复制到另一块空闲的 Survivor空间，随后清空 Eden 和 刚才用过的 Survivor 内存。

注意：由于我们无法保证每次 存活的对象所占内存一直都不大于 Survivor 内存值，所以就会有溢出风险。所以在 **分代收集算法** 中，虚拟机会将内存先划分为一块新生代内存和一块为老年代内存。而在新生代内存中，会采用这种8:1:1的内存分配方式，如果溢出了，就将该情况下的存活对象全部放在老年代内存里，说白了就是一种兜底策略。这里要注意的是，不是溢出的那部分，而是全部的存活对象。

### 标记-整理算法

==标记-整理算法中的标记过程，与标记-清除算法中的标记过程一样，不同的是，当标记完成并清理回收完对象后，会将当前不连续的碎片内存就行整理，即存活的对象都移到一端，来保证接下来要分配的内存的规整性。==我们的 **==分代收集算法==** ==== 中的老年代内存块，就是采用的该算法（当然也可以是标记-清除算法，不同虚拟机的策略不同）。所以就不再对分代收集算法就行赘述了。

好了，本文到这里，关于“对象”的生命周期的讲解就结束了。

本文完。

参考 1、周志明，深入理解JAVA虚拟机：机械工业出版社

---

## Highlights

> 注意：finalize() 方法只会被执行一次，所以一个对象一生只有一次机会进入F-Queue队列，有机会逃脱本此死亡。 [⤴️](https://omnivore.app/me/android-jvm-18df416cd7e#17fb2174-a4bb-4c8c-b8e3-99fc309841d7) 

> ### 标记-清除算法
> 
> 这是最基础的收集算法，主要分为标记和清除两个阶段。首先标记出所以需要回收的对象，在标记完成后统一回收所有被标记的对象。 [⤴️](https://omnivore.app/me/android-jvm-18df416cd7e#d8279998-a4ca-4f3a-929a-554c589802cf) 

> 复制算法是将堆内存分成大小相等的两块，每次只使用其中一块，这样内存就是规整的了，参考指针碰撞。每当一块内存使用完了，就将该块内存中存活的对象复制到另一边，随后将该块内存一次清理掉。 [⤴️](https://omnivore.app/me/android-jvm-18df416cd7e#fbc05da6-5a93-499c-9c42-a9983edc986c) 

> 标记-整理算法中的标记过程，与标记-清除算法中的标记过程一样，不同的是，当标记完成并清理回收完对象后，会将当前不连续的碎片内存就行整理，即存活的对象都移到一端，来保证接下来要分配的内存的规整性。 [⤴️](https://omnivore.app/me/android-jvm-18df416cd7e#77bba3e2-5c8f-412d-9eec-78a424d70376) 

> **分代收集算法**  [⤴️](https://omnivore.app/me/android-jvm-18df416cd7e#20c151f9-9d19-458b-8e74-278bd576a5d3) 

垃圾回收算法主要有三种:
1、标记清除算法
2、标记整理算法
3、标记复制算法

一般不会采用其中一种进行垃圾回收，而是采用分代回收机制，下面就来了解分代回收机制。
https://juejin.cn/post/7031549740248465439

